---
description: 
globs: .tsx,.ts
alwaysApply: false
---
Adding new features in this Redux-based Next.js TypeScript application:

1. Data and Database Structure:
   - First, understand the database structure by querying Supabase using the MCP query tool.
   - Use `mcp_supabase_Parcelo-admin_query` for read-only SQL queries to inspect tables.
   - Document table structures and relationships before implementation.

2. TypeScript Types and Interfaces:
   - Define interfaces in the slice file (e.g., `store/slices/featureSlice.ts`).
   - Use proper TypeScript types for all state properties and API responses.
   - Define the state interface (e.g., `FeatureState`) with all required properties.
   - Use union types for status: 'idle' | 'loading' | 'succeeded' | 'failed'.

3. Redux Store Integration:
   - Add new reducer in the correct slice or create a new slice file in `/store/slices/featureSlice.ts`.
   - Import slice in `/lib/store.ts` (NOT `/store/index.ts` which isn't being used).
   - Create a persistence config with whitelist for fields to persist.
   - Add reducer to the rootReducer with persistReducer.
   - Update RootState type automatically via ReturnType<typeof store.getState>.

4. API Client Implementation:
   - Add API client functions in `/lib/api-client.ts` with proper error handling.
   - Implement both fetch and mutation functions (create, update, delete).
   - Add TypeScript return types and parameter types for all functions.
   - Use try/catch blocks with specific error messages.
5. Redux Slice Implementation:
   - Create in `/store/slices/featureSlice.ts`.
   - Import createSlice, createAsyncThunk, and PayloadAction from @reduxjs/toolkit.
   - Define initial state with proper defaults (empty arrays, null values, status: 'idle').
   - Implement async thunks for all API operations using createAsyncThunk with proper typing.
   - Add all cases to extraReducers using builder pattern.
   - Handle loading/error states consistently in each operation.
   - Export action creators and reducer as default.

6. Component Implementation:
   - Create component in appropriate location (e.g., `/components/admin/feature/FeatureComponent.tsx`).
   - Add 'use client' directive at the top of client components.
   - Use memoized selectors with createSelector to avoid unnecessary re-renders.
   - Add null checks in selectors: (settings) => settings?.property || [].
   - Always import from the correct Redux store: '@/lib/store'.
   - Use useRef for temporary values to avoid unnecessary re-renders.
   - Add dependency arrays to useEffect hooks carefully.
   - Handle form reset only when needed to avoid infinite loops.

7. Mobile Responsiveness:
   - Use Tailwind's responsive classes (md:, lg:, etc.).
   - Test all UI components on mobile and desktop.
   - Implement proper spacing and sizing for mobile devices.
   - Use flex-col on mobile and flex-row on desktop where appropriate.

8. Error Handling:
   - Implement proper error handling for all async operations.
   - Display clear error messages to users.
   - Add loading states for better UX.
   - Use try/catch blocks for all API calls and async operations.
